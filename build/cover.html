
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">k8s-route-extender/cmd/route/create.go (92.5%)</option>
				
				<option value="file1">k8s-route-extender/cmd/route/input.go (100.0%)</option>
				
				<option value="file2">k8s-route-extender/cmd/route/watch.go (13.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package route

import (
        "fmt"
        "time"
        "k8s.io/apimachinery/pkg/types"
        "strconv"
        "strings"
        "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        rbac "k8s.io/api/rbac/v1beta1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/client-go/kubernetes"
        restclient "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/klog"
        "os"
        "path/filepath"
)

var (
        kubeconfig = filepath.Join(os.Getenv("HOME"), ".kube", "config")
        config     *restclient.Config
        err        error
        podcount   = 0
)

const (
        clusterRoleKind    = "ClusterRole"
        roleKind           = "Role"
        serviceAccountKind = "ServiceAccount"
        rbacAPIGroup       = "rbac.authorization.k8s.io"
)


// This is interface for Kubernetes API Server
type KubernetesAPIServer struct {
        Suffix string
        Client kubernetes.Interface
}

type QueueUpdate struct {
        Key   string
        Force bool
}


// This creates go client.
func CreateK8sApiserverClient() (*KubernetesAPIServer, error) <span class="cov8" title="1">{
        klog.Info("[INFO] Creating API Client")
        api := &amp;KubernetesAPIServer{}
        config, err = clientcmd.BuildConfigFromFlags("", "")
        if err != nil </span><span class="cov8" title="1">{
                klog.Error("[WARNING] Citrix Node Controller Runs outside cluster")
                config, err = clientcmd.BuildConfigFromFlags("", kubeconfig)
                if err != nil </span><span class="cov0" title="0">{
                        klog.Error("[ERROR] Did not find valid kube config info")
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">client, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                klog.Error("[ERROR] Failed to establish connection")
                klog.Fatal(err)
        }</span>
        <span class="cov8" title="1">klog.Info("[INFO] Kubernetes Client is created")
        api.Client = client
        return api, nil</span>
}

func (api *KubernetesAPIServer)CreateK8sNameSpace()(string, error)<span class="cov8" title="1">{
        nameSpace := "k8s-route-extender"
        nsObj, err := api.Client.CoreV1().Namespaces().Get(nameSpace,  metav1.GetOptions{})
        fmt.Println("Name Space object", nsObj)
        if err != nil </span><span class="cov8" title="1">{
                nsSpec := &amp;v1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: nameSpace}}
                nsObj, err = api.Client.CoreV1().Namespaces().Create(nsSpec)
                if err == nil </span><span class="cov8" title="1">{
                        return "k8s-route-extender", err
                }</span>else<span class="cov8" title="1">{
                        return "Error", err
                }</span>
        }
        <span class="cov8" title="1">return "k8s-route-extender", err</span>
}

func (api *KubernetesAPIServer)CreateK8sServiceAccount(input *Input)(string, error)<span class="cov8" title="1">{
        serviceAccountName := "k8s-route-extender"
        saObj, err := api.Client.CoreV1().ServiceAccounts(input.NameSpace).Get(serviceAccountName,  metav1.GetOptions{})
        fmt.Println("Name Space object", saObj)
        if err != nil </span><span class="cov8" title="1">{
                serviceAccount := &amp;v1.ServiceAccount{ObjectMeta: metav1.ObjectMeta{Name: serviceAccountName}}
                _, err := api.Client.CoreV1().ServiceAccounts(input.NameSpace).Create(serviceAccount)
                if err == nil </span><span class="cov8" title="1">{
                        return "k8s-route-extender", err
                }</span>else<span class="cov8" title="1">{
                        return "Error", err
                }</span>
        }
        <span class="cov8" title="1">return "k8s-route-extender", err</span>
}

func (api *KubernetesAPIServer)CreateK8sConfigMap(input *Input)(string, error)<span class="cov8" title="1">{
        configMapName := "k8s-route-extender"
        configMaps, err := api.Client.CoreV1().ConfigMaps(input.NameSpace).Get(configMapName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                configMap := &amp;v1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: configMapName}}
                configMaps, err = api.Client.CoreV1().ConfigMaps(input.NameSpace).Create(configMap)
                if err == nil </span><span class="cov8" title="1">{
                        return "k8s-route-extender", err
                }</span>else<span class="cov8" title="1">{
                        return "Error", err
                }</span>
        }
        <span class="cov8" title="1">fmt.Println("Config map object", configMaps)
        return "k8s-route-extender", err</span>
}

func (api *KubernetesAPIServer)CreateClusterRoles(input *Input) error <span class="cov8" title="1">{
        Verbs := []string{"get", "list", "watch", "create", "patch"}
        Apigroups := []string{"*"}
        ApigroupsSecond := []string{""}
        ApigroupsThird := []string{"extensions"}
        Resources := []string{"configmaps"}
        clusterRole := rbac.ClusterRole{
                ObjectMeta: metav1.ObjectMeta{
                        Name: "k8s-route-extender",
                },
                Rules: []rbac.PolicyRule{
                        {
                                APIGroups:      Apigroups,
                                Resources:      Resources,
                                Verbs:                 Verbs,
                        },
                        {
                                APIGroups:      ApigroupsSecond,
                                Resources:      Resources,
                                Verbs:                 Verbs,
                        },
                        {
                                APIGroups:      ApigroupsThird,
                                Resources:      Resources,
                                Verbs:                 Verbs,
                        },
                },
        }

        if _, err := api.Client.RbacV1beta1().ClusterRoles().Create(&amp;clusterRole); err != nil </span><span class="cov8" title="1">{
                if !apierrors.IsAlreadyExists(err) </span><span class="cov8" title="1">{
                        return fmt.Errorf("unable to create RBAC clusterrolebinding: %v", err)
                }</span>

                <span class="cov8" title="1">if _, err := api.Client.RbacV1beta1().ClusterRoles().Update(&amp;clusterRole); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to update RBAC clusterrolebinding: %v", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (api *KubernetesAPIServer)CreateClusterRoleBindings(input *Input) error <span class="cov8" title="1">{
        clusterRoleBinding := rbac.ClusterRoleBinding{
                ObjectMeta: metav1.ObjectMeta{
                        Name: "k8s-route-extender",
                },
                RoleRef: rbac.RoleRef{
                        APIGroup: rbacAPIGroup,
                        Kind:     clusterRoleKind,
                        Name:     "k8s-route-extender",
                },
                Subjects: []rbac.Subject{
                        {
                                Kind:      serviceAccountKind,
                                Name:      "k8s-route-extender",
                                Namespace: input.NameSpace,
                        },
                },
        }

        if _, err := api.Client.RbacV1beta1().ClusterRoleBindings().Create(&amp;clusterRoleBinding); err != nil </span><span class="cov8" title="1">{
                if !apierrors.IsAlreadyExists(err) </span><span class="cov8" title="1">{
                        return fmt.Errorf("unable to create RBAC clusterrolebinding: %v", err)
                }</span>

                <span class="cov8" title="1">if _, err := api.Client.RbacV1beta1().ClusterRoleBindings().Update(&amp;clusterRoleBinding); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to update RBAC clusterrolebinding: %v", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}


func Create()<span class="cov8" title="1">{
        input := GetUserInput()
        api,_ := CreateK8sApiserverClient()
        nameSpace, _  := api.CreateK8sNameSpace()
        input.NameSpace = nameSpace
        api.CreateClusterRoles(input)
        api.CreateClusterRoleBindings(input)
        serviceAccount, _  := api.CreateK8sServiceAccount(input)
        input.ServiceAccount = serviceAccount
        configMap, _  := api.CreateK8sConfigMap(input)
        input.ConfigMap = configMap
        fmt.Println("Namespace", nameSpace, serviceAccount, configMap)
        WatchNodeEvents(api, input)
        if (input.Mode == "Dev")</span><span class="cov0" title="0">{
                select</span>{}
        }
}


func GenerateNextAddress(input *Input)string<span class="cov8" title="1">{

        ipaddress := strings.Split(input.NextAddress, ".")
        firstOctect, _ := strconv.Atoi(ipaddress[3])
        secondOctect, _ := strconv.Atoi(ipaddress[2])
        thirdOctect, _ := strconv.Atoi(ipaddress[1])
        prefix, _ := strconv.Atoi(input.PrefixLen)
        if (prefix &gt;= 24)</span><span class="cov8" title="1">{
                if (firstOctect&lt;254)</span><span class="cov8" title="1">{
                        firstOctect = firstOctect+1
                        input.NextAddress = ipaddress[0]+"."+ipaddress[1]+"."+ipaddress[2]+"."+strconv.Itoa(firstOctect)
                }</span>else<span class="cov8" title="1">{
                        fmt.Println("[ERROR] No More IP is  avialable in the given subnet")
                }</span>        
        }else<span class="cov8" title="1"> if (prefix &gt;= 16)</span><span class="cov8" title="1">{
                if (firstOctect&lt;254)</span><span class="cov8" title="1">{
                        firstOctect = firstOctect+1
                        input.NextAddress = ipaddress[0]+"."+ipaddress[1]+"."+ipaddress[2]+"."+strconv.Itoa(firstOctect)
                }</span>else<span class="cov8" title="1"> if (secondOctect &lt; 254)</span><span class="cov8" title="1">{
                        secondOctect = secondOctect+1
                        input.NextAddress = ipaddress[0]+"."+ipaddress[1]+"."+strconv.Itoa(secondOctect)+"."+ipaddress[3]
                }</span>else<span class="cov8" title="1">{
                        fmt.Println("[ERROR] No More IP is  avialable in the given subnet")
                }</span>
        }else<span class="cov8" title="1"> if (prefix &gt;= 8)</span><span class="cov8" title="1">{
                if (firstOctect&lt;254)</span><span class="cov8" title="1">{
                        firstOctect = firstOctect+1
                        input.NextAddress = ipaddress[0]+"."+ipaddress[1]+"."+ipaddress[2]+"."+strconv.Itoa(firstOctect)
                }</span>else<span class="cov8" title="1"> if (secondOctect &lt; 254)</span><span class="cov8" title="1">{
                        secondOctect = secondOctect+1
                        input.NextAddress = ipaddress[0]+"."+ipaddress[1]+"."+strconv.Itoa(secondOctect)+"."+ipaddress[3]
                }</span>else<span class="cov8" title="1"> if (thirdOctect &lt; 254)</span><span class="cov8" title="1">{
                        thirdOctect = thirdOctect+1
                        input.NextAddress = ipaddress[0]+"."+strconv.Itoa(thirdOctect)+"."+ipaddress[2]+"."+ipaddress[3]
                }</span>else<span class="cov8" title="1">{
                        fmt.Println("[ERROR] No More IP is  avialable in the given subnet")
                }</span>
        }        
        <span class="cov8" title="1">return (input.NextAddress+"/"+input.PrefixLen)</span>
}

func (api *KubernetesAPIServer)CreateKubeExtenderPod(obj interface{}, node *Node, originalNode v1.Node, input *Input) <span class="cov8" title="1">{
        podcount = podcount + 1
        ifip := GenerateNextAddress(input)
        klog.Info("[INFO] Generating PODCIDR and Node Information")
        patchBytes := []byte(fmt.Sprintf(`{"metadata":{"labels":{"NodeID":"%s"}}}`, "Node"+strconv.Itoa(podcount)))
        time.Sleep(10 * time.Second) //TODO, We have to wait till Node is available.
        if _, err = api.Client.CoreV1().Nodes().Patch(originalNode.Name, types.StrategicMergePatchType, patchBytes); err != nil </span><span class="cov8" title="1">{
                klog.Errorf("[ERROR] Failed to Patch label %v", err)
        }</span> else<span class="cov0" title="0"> {
                klog.Info("[INFO] Updated node  label")
        }</span>
        <span class="cov8" title="1">command := []string{"/bin/bash", "-c"}
        args := []string{
                "ip link add citrixvxlan0 type vxlan id ${vni}  dev eth0  dstport 0; ip addr add $(address) dev citrixvxlan0; ip link set up dev citrixvxlan0; vtepmac=`ifconfig citrixvxlan0 | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}' `; echo \"InterfaceInfo ${vtepmac}\"; theIPaddress=`ip -4 addr show citrixvxlan0  | grep inet | awk '{print $2}' | cut -d/ -f1`;  hostip=`ip -4 addr show eth0  | grep inet | awk '{print $2}' | cut -d/ -f1`; echo \"IP Addredd ${theIPaddress}\"; echo \"Host IP Address ${hostip}\"; `kubectl patch configmap ${configMap} -n ${nameSpace}  -p '{\"data\":{\"'\"Mac-$hostip\"'\": \"'\"$vtepmac\"'\"}}'`;  `kubectl patch configmap ${configMap} -n ${nameSpace} -p '{\"data\":{\"'\"Interface-$hostip\"'\": \"'\"$theIPaddress\"'\"}}'`; `kubectl patch configmap ${configMap} -n ${nameSpace} -p '{\"data\":{\"'\"Node-$hostip\"'\": \"'\"$hostip\"'\"}}'`;  ip route add ${network}  via  ${nexthop} dev citrixvxlan0 onlink; bridge fdb add ${ingmac} dev citrixvxlan0 dst ${vtepip}; sleep 3d;"}


        SecurityContext := new(v1.SecurityContext)
        Capabilities := new(v1.Capabilities)
        Capabilities.Add = append(Capabilities.Add, "NET_ADMIN")
        SecurityContext.Capabilities = Capabilities
        pod := &amp;v1.Pod{
                ObjectMeta: metav1.ObjectMeta{
                        Name: "kuberoutesextender" + strconv.Itoa(podcount),
                },
                Spec: v1.PodSpec{
                        ServiceAccountName: input.ServiceAccount,
                        HostNetwork:        true,
                        Containers: []v1.Container{
                                {
                                        Name:            "kuberoutesextender" + strconv.Itoa(podcount),
                                        Image:           "quay.io/citrix/dummynode:latest",
                                        Command:         command,
                                        Args:            args,
                                        SecurityContext: SecurityContext,
                                        Env: []v1.EnvVar{
                                                {Name: "network", Value: input.Network},
                                                {Name: "nexthop", Value: input.Netmask},
                                                {Name: "ingmac", Value: "00:00:00:00:00:00"},
                                                {Name: "vtepip", Value: input.RemoteVtepIP},
                                                {Name: "configMap", Value: input.ConfigMap},
                                                {Name: "nameSpace", Value: input.NameSpace},
                                                {Name: "vni", Value: input.Vnid},
                                                {Name: "address", Value: ifip},
                                        },
                                },
                        },
                },
        }
        nodeSelector := make(map[string]string)
        nodeSelector["NodeID"] = "Node"+strconv.Itoa(podcount)
        pod.Spec.NodeSelector = nodeSelector
        
        if _, err = api.Client.CoreV1().Pods(input.NameSpace).Create(pod); err != nil </span><span class="cov0" title="0">{
              klog.Error("Failed to Create a Pod " + err.Error())
        }</span>
        <span class="cov8" title="1">time.Sleep(60 * time.Second) //TODO, We have to wait till Pod is available.

        pod, err = api.Client.CoreV1().Pods(input.NameSpace).Get(pod.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
              fmt.Errorf("pod Get API error: %v \n pod: %v", err, pod)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package route

import (
        "fmt"
        "os"
        "strings"
        "strconv"
        "encoding/binary"
)

type Input struct{
        Mode string
        NameSpace string
        ServiceAccount string
        ConfigMap string
        Address string
        NodeIP string
        Network string
        PrefixLen string
        Netmask string
        Vnid        string
        RemoteVtepIP string
        NextAddress string
}

func ValidateAddress(address string)bool<span class="cov8" title="1">{
        ipaddress := strings.Split(address, ".")
        firstOctect, err := strconv.Atoi(ipaddress[0])
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if firstOctect &lt; 0 || firstOctect &gt; 255 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">secondOctect, err := strconv.Atoi(ipaddress[1])
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if secondOctect &lt; 0 || secondOctect &gt; 255 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">thirdOctect, err := strconv.Atoi(ipaddress[2])
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if thirdOctect &lt; 0 || thirdOctect &gt; 255 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">fourthOctect, err := strconv.Atoi(ipaddress[3])

        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if fourthOctect &lt; 0 || fourthOctect &gt; 255 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// ConvertPrefixLenToMask convert the prefix len to netmask (dotted) format.
func ConvertPrefixLenToMask(prefixLen string) string <span class="cov8" title="1">{
        len, _ := strconv.Atoi(prefixLen)
        netmask := (uint32)(^(1&lt;&lt;(32-(uint32)(len)) - 1))
        bytes := make([]byte, 4)
        binary.BigEndian.PutUint32(bytes, netmask)
        fmt.Println("NETMASK", bytes)
        netmaskdot := fmt.Sprintf("%d.%d.%d.%d", bytes[0], bytes[1], bytes[2], bytes[3])
        return netmaskdot
}</span>


func ValidatePrefixLen(prefixlen string)bool<span class="cov8" title="1">{
        len,_ := strconv.Atoi(prefixlen)
        if (len &lt;=0 || len&gt;=32)</span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func ExtractNetworkAndPrefix(address string)(string, string)<span class="cov8" title="1">{
        data := strings.Split(address, "/") 
        prefixLen := data[1]
        network   := data[0]
        return network, prefixLen
}</span>

var PrefixSubnetTable = make(map[string]string)
func InitPrefixSubnetTable()<span class="cov8" title="1">{
        PrefixSubnetTable["8"] = "0"
        PrefixSubnetTable["9"] = "128"
        PrefixSubnetTable["10"] = "192"
        PrefixSubnetTable["11"] = "224"
        PrefixSubnetTable["12"] = "240"
        PrefixSubnetTable["13"] = "248"
        PrefixSubnetTable["14"] = "252"
        PrefixSubnetTable["15"] = "254"
        PrefixSubnetTable["16"] = "0"
        PrefixSubnetTable["17"] = "128"
        PrefixSubnetTable["18"] = "192"
        PrefixSubnetTable["19"] = "224"
        PrefixSubnetTable["20"] = "240"
        PrefixSubnetTable["21"] = "248"
        PrefixSubnetTable["22"] = "252"
        PrefixSubnetTable["23"] = "254"
        PrefixSubnetTable["24"] = "0"
        PrefixSubnetTable["25"] = "128"
        PrefixSubnetTable["26"] = "192"
        PrefixSubnetTable["27"] = "224"
        PrefixSubnetTable["28"] = "240"
        PrefixSubnetTable["29"] = "248"
        PrefixSubnetTable["30"] = "252"
        PrefixSubnetTable["31"] = "254"
        PrefixSubnetTable["32"] = "255"
}</span>


func InitializeNodeIP(input *Input)<span class="cov8" title="1">{
        InitPrefixSubnetTable()
        SubnetMasked := strings.Split(input.Network, ".")
        var network int
        var Network string
        prefix,_ := strconv.Atoi(input.PrefixLen)
        if (prefix &gt;= 24)</span><span class="cov8" title="1">{
                tmp_start := SubnetMasked[3]
                tmp, _ := strconv.Atoi(tmp_start)
                tmp2,_ := strconv.Atoi(PrefixSubnetTable[input.PrefixLen])
                network = tmp &amp; tmp2
                Network = SubnetMasked[0]+"."+SubnetMasked[1]+"."+SubnetMasked[2]+"."+strconv.Itoa(network)
        }</span> else<span class="cov8" title="1"> if (prefix &gt;= 16)</span><span class="cov8" title="1">{
                tmp_start := SubnetMasked[2]
                tmp, _ := strconv.Atoi(tmp_start)
                tmp2,_ := strconv.Atoi(PrefixSubnetTable[input.PrefixLen])
                network = tmp &amp; tmp2
                Network = SubnetMasked[0]+"."+SubnetMasked[1]+"."+strconv.Itoa(network)+".0"
        }</span>else<span class="cov8" title="1"> if (prefix &gt;= 8)</span><span class="cov8" title="1">{
                tmp_start := SubnetMasked[1]
                tmp, _ := strconv.Atoi(tmp_start)
                tmp2,_ := strconv.Atoi(PrefixSubnetTable[input.PrefixLen])
                network = tmp &amp; tmp2
                Network = SubnetMasked[0]+"."+strconv.Itoa(network)+".0.0"
        }</span>
        <span class="cov8" title="1">input.NextAddress = Network</span>
}

func GetUserInput() (*Input)<span class="cov8" title="1">{
        input := new(Input)
        input.Mode = "Dev"
        if (os.Getenv("MODE") == "Test")</span><span class="cov8" title="1">{
                input.Mode = "Test"
        }</span>
        <span class="cov8" title="1">configError := 0
        input.Address = os.Getenv("ADDRESS")
        if len(input.Address) == 0 </span><span class="cov8" title="1">{
                fmt.Println("[ERROR] New Private Subnet (ADDRESS Eg 192.168.1.0/16) is must for extending the route")
                configError = 1
        }</span>else<span class="cov8" title="1"> {
                input.Network, input.PrefixLen = ExtractNetworkAndPrefix(input.Address)
                if !(ValidateAddress(input.Network))</span><span class="cov8" title="1">{
                        fmt.Println("[ERROR] Invalid Address format (ADDRESS Eg 192.168.1.2)")
                        configError = 1
                }</span>
                <span class="cov8" title="1">if !(ValidatePrefixLen(input.PrefixLen))</span><span class="cov8" title="1">{
                        fmt.Println("[ERROR] Invalid Address prefix len (0&gt;prefixlen&lt;32)")
                        configError = 1
                }</span>
        }
        <span class="cov8" title="1">input.Vnid = os.Getenv("VNID")
        if len(input.Vnid) == 0 </span><span class="cov8" title="1">{
                fmt.Println("[ERROR] A unique VNID (VNID) is must for extending the route")
                configError = 1
        }</span>
        <span class="cov8" title="1">input.RemoteVtepIP = os.Getenv("REMOTE_VTEPIP")
        if len(input.RemoteVtepIP) == 0 </span><span class="cov8" title="1">{
                fmt.Println("[ERROR] A unique REMOTE_VTEPIP (REMOTE_VTEPIP) is must for extending the route")
                configError = 1
        }</span>
        <span class="cov8" title="1">if configError == 1 </span><span class="cov8" title="1">{
                fmt.Println("Unable to get the above mentioned input from YAML")
                panic("[ERROR] Killing Container.........Please restart  with Valid Inputs")</span>
        }
        <span class="cov8" title="1">InitializeNodeIP(input)
        fmt.Println("Next Address", input.NextAddress)
        return input</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package route

import (
        "encoding/json"
//        "fmt"
//        "time"
//        "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/fields"
//        appv1 "k8s.io/api/apps/v1"
        "k8s.io/api/core/v1"
//        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
//        "k8s.io/client-go/kubernetes"
//        restclient "k8s.io/client-go/rest"
//        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/klog"
//        "os"
//        "path/filepath"
//        "strconv"
        "k8s.io/client-go/tools/cache"
)

func ParseNodeRoles(node *Node, originalNode v1.Node) <span class="cov0" title="0">{
        for _, Role := range originalNode.Spec.Taints </span><span class="cov0" title="0">{
                if Role.Key == "node-role.kubernetes.io/master" </span><span class="cov0" title="0">{
                        node.Role = "Master"
                }</span>
        }
}

func WatchNodeEvents(api *KubernetesAPIServer, input *Input)<span class="cov8" title="1">{

        nodeListWatcher := cache.NewListWatchFromClient(api.Client.CoreV1().RESTClient(), "nodes", v1.NamespaceAll, fields.Everything())
        _, nodecontroller := cache.NewInformer(nodeListWatcher, &amp;v1.Node{}, 0, cache.ResourceEventHandlerFuncs{
                AddFunc: func(obj interface{}) </span><span class="cov0" title="0">{
                        CoreAddHandler(api, obj, input)
                }</span>,
                UpdateFunc: func(obj interface{}, newobj interface{}) <span class="cov0" title="0">{
                        CoreUpdateHandler(api, obj, newobj)
                }</span>,
                DeleteFunc: func(obj interface{}) <span class="cov0" title="0">{
                        CoreDeleteHandler(api, obj, nil)
                }</span>,
        },
        )
        <span class="cov8" title="1">stop := make(chan struct{})
        go nodecontroller.Run(stop)
        return</span>
}

func CoreAddHandler(api *KubernetesAPIServer, obj interface{}, input *Input) <span class="cov0" title="0">{
        ParseNodeEvents(api, obj, input)
}</span>

type Node struct {
        Role string
        Label string
        IPAddr string
        HostName string
        ExternalIPAddr string
        PodAddress string
        PodVTEP string
        PodNetMask string
        PodMaskLen string
}
// ParseNodeEvents Parses the node object and store the fields to Node.
func ParseNodeEvents(api *KubernetesAPIServer, obj interface{}, input *Input) *Node <span class="cov0" title="0">{
        node := new(Node)
        node.Role = ""
        node.Label = ""
        originalObjJS, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("[ERROR] Failed to Marshal original object: %v", err)
        }</span>
        <span class="cov0" title="0">var originalNode v1.Node
        if err = json.Unmarshal(originalObjJS, &amp;originalNode); err != nil </span><span class="cov0" title="0">{
                klog.Errorf("[ERROR] Failed to unmarshal original object: %v", err)
        }</span>
        //PodCIDR := originalNode.Spec.PodCIDR
        //InternalIP, ExternalIP, HostName := GetNodeAddress(originalNode)
        <span class="cov0" title="0">InternalIP := "1.1.1.1"
        ExternalIP := "1.1.1.1"
        HostName := "abc"
        node.IPAddr = InternalIP
        node.HostName = HostName
        node.ExternalIPAddr = ExternalIP
        if originalNode.Spec.Taints != nil </span><span class="cov0" title="0">{
                klog.Info("[INFO] Taint Information", originalNode.Spec.Taints)
                ParseNodeRoles(node, originalNode)
                klog.Info("[INFO] Setting Node Role", node.Role)
        }</span>
        <span class="cov0" title="0">if node.Role != "Master" </span><span class="cov0" title="0">{
                klog.Errorf("[WARNING] Does not have PodCIDR Information, CNC will Generate itself")
                api.CreateKubeExtenderPod(obj, node, originalNode, input)
        }</span>
        <span class="cov0" title="0">return node</span>
}


func CoreUpdateHandler(api *KubernetesAPIServer, obj interface{}, newobj interface{}) <span class="cov0" title="0">{
        return
}</span>
func CoreDeleteHandler(api *KubernetesAPIServer, obj interface{}, newobj interface{}) <span class="cov0" title="0">{
        return
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
